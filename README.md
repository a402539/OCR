Распознавание текста
================

Сборка
------

Для сборки требуется `NodeJS`.

Предварительно нужно установить jake (глобально) и другие зависимости плагина:
```
npm install -g jake
npm install
```

Для сборки production версии выполнить команду
```
jake
```

В папке `dist` появятся файлы `textExtract.js` и `textExtract-src.js`. Не нужно коммитить эти файлы в репозиторий!

Для сборки версии для разработки (динамически подключающую все исходные файлы) выполнить команду

```
jake dev
```

Для корректной сборки нужно поддерживать актуальным файл со списком исходников (`build/deps.js`). Сборку для разработки нужно выполнять при каждом изменении этого списка.

При добавлении модуля *.js

+ Прописать его в файле `build/deps.js`
+ Из папки OCR запустить команду `jake dev`

Алгоритм выделения символов
------

Имеется двумерная таблица с булевыми элементами. Истина означает черную точку, Ложь - белую.
Две черные точки являются соседними, если их обе координаты отличются не больше чем на единицу.
Множество точек связное, если любые две точки могут быть связаны последовательностью соседних точек.
Это связное множество черных точек максимальное, если к нему нельзя добавить черную точку, соседнюю к одной из точек множества.

Символ - максимальное связное множество черных точек.

***
Задача: Найти все символы в двумерной таблице.
--

Решение:
Первоначально множество символов пусто.
Обходим точки построчно, слева направо, сверху вниз.

Для каждой очередной точки:

1. Если она белая, продолжить
2. Если она черная, определяем, к какому символу ее отнести.
     Для этого проверяем три соседние точки сверху и соседнюю точку слева.

 > 2.1. Среди них есть черные точки из разных символов (это возможно только в случае, когда одна из левых точек (или обе) и правая верхняя точки относятся к разным символам)
 
 >> 2.1.1. Относим все точки второго символа к первому символу и второй символ удаляем
 
 >> 2.1.2. Относим текущую точку к первому символу

 > 2.2. Среди них есть черные точки, но все они отнесены к одному символу
  Относим текущую точку к этому символу
  
 > 2.3. Среди них черных точек нет
  Создаем новый символ и относим к нему текущую точку
  
***
Задача: сравнить два битмэпа разных размеров
--
Данные: два битмэпа в виде прямоугольных областей пикселов.

Идея решения:

1. привести эти битмэпы к одному размеру, умножением по строкам на НОК размеров строк и по столбцам на НОК размеров столбцов
2. наложить один битмэп на другой, показать цветом разницу и подсчитать процент/количество совпадающих пикселов (или процент/количество отличающихся)

Задача имеет смысл и для одномерных областей.

Пример 1.

          Битмэп1 х1 х2
          Битмэп2 н1 н2 н3
          НОК(2,3)=6
          Битмэп1 х1 х1 х1 х2 х2 х2
          Битмэп2 н1 н1 н2 н2 н3 н3
          Разница=2*разница(х1,н1)+разница(х1,н2)+разница(х2,н2)+2*разница(х2,н3)

          Если увеличивать не до 6, а до 12:
          Битмэп1 х1 х1 х1 х1 х1 х1 х2 х2 х2 х2 х2 х2
          Битмэп2 н1 н1 н1 н1 н2 н2 н2 н2 н3 н3 н3 н3
          Разница=4*разница(х1,н1)+2*разница(х1,н2)+2*разница(х2,н3)+4*разница(х2,н3)

Если поделить на размер обзего битмэпа, то эти две оценки разницы совпадают

Т.е. можно общий размер делать не НОК, а любое кратное размеров (не обязательно наименьшее)

Одномерная задача. Общий случай.

          Битмэп1: число элементов к1
          Битмэп2: число элементов к2
          Общее кратное к=к1*к2

          БМ1 размер а1 X[0..(a1-1)]
          БМ2 размер а2 Y[0..(a2-1)]
          for(i=0,S=0; i<a1*a2; i++){S+=разница(X[i%a2],Y[i%a1]}
               S=S/(a1*a2);
               где разница(X,Y)=
                    0, если X=Y
                    1, если X<>Y

Двумерная модель.

          БМ1 размер a1*b1 X[0..(a1-1),0..(b1-1)]
          БМ2 размер a2*b2 X[0..(a2-1),0..(b2-1)]
          for(i=0,S=0; i<a1*a2; i++){for(j=0; j<b1*b2; i++){S+=разница(X[i%a2,j%b2],Y[i%a1,j%b1]}
          S=S/(a1*a2*b1*b2);
          где разница(X,Y)=abs(яркость(X),яркость(Y))/255

Улучшение алгоритма сравнения.

Стандартный алгоритм видится так:

     сравниваем битмэп с битмэпами всех символов и берем тот, разница с которым наименьшая.
Улучшение:

     Минимальную разницу брать в результатах сравнения не только исходного битмэпа, но и его сдвигов влево,
     вправо (на расстояние от `-a1*a2 до a1*a2`), вниз и вверх (от `-b1*b2 до b1*b2`)

=====================================
Переход от толстого символа к контуру

Дано: Прямоугольная область черно-белых пикселов. Черные пикселы составляют символ.

Найти: контур (границу) символа.

Решение:
В цикле по строкам сверху вниз и столбцам слева направо:

     123
     456
     789

Для текущей точки (точки 5) рассматриваем ближайших соседей.
Если она белая, ничего не делаем. переходим к следующей точке (направо).
Если она черная, проверяем, на сколько множеств соседних черных точек делятся окружающие точку 5 точки 12369874.
При этом соседними считаются точки, расстоние между которыми меньше 2 единиц.
Скажем, точки 26, 68, 84, 42 - попарно соседние.
Соседние черные точки относим к одному множеству.
Точки разных множеств по определению отстоят друг от друга на расстояние больше или равное 2.
Если таких множеств больше 1, тогда точку 5 оставляем черной. 
Если 0 (т.е. все точки белые) или 1 (т.е. черные точки составляют один непрерывный диапазон), тогда точку 5 делаем белой.

     Пример 1. Если черные точки обозначать х, а белые о, то
     ххо     ххо                                                             ххо
     ххо ==> х о ==> множеств два, поэтому оставляем центр. точку черной ==> ххо
     оох     оох                                                             оох
     
     Пример 2.
     ххо     ххо                                                           ххо
     ххо ==> х о ==> множество одно, поэтому делаем центр. точку белой ==> хоо
     охх     охх                                                           охх


